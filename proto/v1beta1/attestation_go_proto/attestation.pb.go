// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/v1beta1/attestation.proto

package attestation_go_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	common_go_proto "github.com/grafeas/grafeas/proto/v1beta1/common_go_proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Type (for example schema) of the attestation payload that was signed.
type PgpSignedAttestation_ContentType int32

const (
	// `ContentType` is not set.
	PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED PgpSignedAttestation_ContentType = 0
	// Atomic format attestation signature. See
	// https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
	// The payload extracted from `signature` is a JSON blob conforming to the
	// linked schema.
	PgpSignedAttestation_SIMPLE_SIGNING_JSON PgpSignedAttestation_ContentType = 1
)

var PgpSignedAttestation_ContentType_name = map[int32]string{
	0: "CONTENT_TYPE_UNSPECIFIED",
	1: "SIMPLE_SIGNING_JSON",
}

var PgpSignedAttestation_ContentType_value = map[string]int32{
	"CONTENT_TYPE_UNSPECIFIED": 0,
	"SIMPLE_SIGNING_JSON":      1,
}

func (x PgpSignedAttestation_ContentType) String() string {
	return proto.EnumName(PgpSignedAttestation_ContentType_name, int32(x))
}

func (PgpSignedAttestation_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{0, 0}
}

// Type of the attestation plaintext that was signed.
type GenericSignedAttestation_ContentType int32

const (
	// `ContentType` is not set.
	GenericSignedAttestation_CONTENT_TYPE_UNSPECIFIED GenericSignedAttestation_ContentType = 0
	// Atomic format attestation signature. See
	// https://github.com/containers/image/blob/8a5d2f82a6e3263290c8e0276c3e0f64e77723e7/docs/atomic-signature.md
	// The payload extracted in `plaintext` is a JSON blob conforming to the
	// linked schema.
	GenericSignedAttestation_SIMPLE_SIGNING_JSON GenericSignedAttestation_ContentType = 1
)

var GenericSignedAttestation_ContentType_name = map[int32]string{
	0: "CONTENT_TYPE_UNSPECIFIED",
	1: "SIMPLE_SIGNING_JSON",
}

var GenericSignedAttestation_ContentType_value = map[string]int32{
	"CONTENT_TYPE_UNSPECIFIED": 0,
	"SIMPLE_SIGNING_JSON":      1,
}

func (x GenericSignedAttestation_ContentType) String() string {
	return proto.EnumName(GenericSignedAttestation_ContentType_name, int32(x))
}

func (GenericSignedAttestation_ContentType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{1, 0}
}

// An attestation wrapper with a PGP-compatible signature. This message only
// supports `ATTACHED` signatures, where the payload that is signed is included
// alongside the signature itself in the same file.
type PgpSignedAttestation struct {
	// Required. The raw content of the signature, as output by GNU Privacy Guard
	// (GPG) or equivalent. Since this message only supports attached signatures,
	// the payload that was signed must be attached. While the signature format
	// supported is dependent on the verification implementation, currently only
	// ASCII-armored (`--armor` to gpg), non-clearsigned (`--sign` rather than
	// `--clearsign` to gpg) are supported. Concretely, `gpg --sign --armor
	// --output=signature.gpg payload.json` will create the signature content
	// expected in this field in `signature.gpg` for the `payload.json`
	// attestation payload.
	Signature string `protobuf:"bytes,1,opt,name=signature,proto3" json:"signature,omitempty"`
	// Type (for example schema) of the attestation payload that was signed.
	// The verifier must ensure that the provided type is one that the verifier
	// supports, and that the attestation payload is a valid instantiation of that
	// type (for example by validating a JSON schema).
	ContentType PgpSignedAttestation_ContentType `protobuf:"varint,3,opt,name=content_type,json=contentType,proto3,enum=grafeas.v1beta1.attestation.PgpSignedAttestation_ContentType" json:"content_type,omitempty"`
	// This field is used by verifiers to select the public key used to validate
	// the signature. Note that the policy of the verifier ultimately determines
	// which public keys verify a signature based on the context of the
	// verification. There is no guarantee validation will succeed if the
	// verifier has no key matching this ID, even if it has a key under a
	// different ID that would verify the signature. Note that this ID should also
	// be present in the signature content above, but that is not expected to be
	// used by the verifier.
	//
	// Types that are valid to be assigned to KeyId:
	//	*PgpSignedAttestation_PgpKeyId
	KeyId                isPgpSignedAttestation_KeyId `protobuf_oneof:"key_id"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *PgpSignedAttestation) Reset()         { *m = PgpSignedAttestation{} }
func (m *PgpSignedAttestation) String() string { return proto.CompactTextString(m) }
func (*PgpSignedAttestation) ProtoMessage()    {}
func (*PgpSignedAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{0}
}

func (m *PgpSignedAttestation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_PgpSignedAttestation.Unmarshal(m, b)
}
func (m *PgpSignedAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_PgpSignedAttestation.Marshal(b, m, deterministic)
}
func (m *PgpSignedAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_PgpSignedAttestation.Merge(m, src)
}
func (m *PgpSignedAttestation) XXX_Size() int {
	return xxx_messageInfo_PgpSignedAttestation.Size(m)
}
func (m *PgpSignedAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_PgpSignedAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_PgpSignedAttestation proto.InternalMessageInfo

func (m *PgpSignedAttestation) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

func (m *PgpSignedAttestation) GetContentType() PgpSignedAttestation_ContentType {
	if m != nil {
		return m.ContentType
	}
	return PgpSignedAttestation_CONTENT_TYPE_UNSPECIFIED
}

type isPgpSignedAttestation_KeyId interface {
	isPgpSignedAttestation_KeyId()
}

type PgpSignedAttestation_PgpKeyId struct {
	PgpKeyId string `protobuf:"bytes,2,opt,name=pgp_key_id,json=pgpKeyId,proto3,oneof"`
}

func (*PgpSignedAttestation_PgpKeyId) isPgpSignedAttestation_KeyId() {}

func (m *PgpSignedAttestation) GetKeyId() isPgpSignedAttestation_KeyId {
	if m != nil {
		return m.KeyId
	}
	return nil
}

func (m *PgpSignedAttestation) GetPgpKeyId() string {
	if x, ok := m.GetKeyId().(*PgpSignedAttestation_PgpKeyId); ok {
		return x.PgpKeyId
	}
	return ""
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*PgpSignedAttestation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*PgpSignedAttestation_PgpKeyId)(nil),
	}
}

// An attestation wrapper that uses the Grafeas `Signature` message.
// This attestation must define the `serialized_payload` that the `signatures` verify
// and any metadata necessary to interpret that plaintext.  The signatures
// should always be over the `serialized_payload` bytestring.
type GenericSignedAttestation struct {
	// Type (for example schema) of the attestation payload that was signed.
	// The verifier must ensure that the provided type is one that the verifier
	// supports, and that the attestation payload is a valid instantiation of that
	// type (for example by validating a JSON schema).
	ContentType GenericSignedAttestation_ContentType `protobuf:"varint,1,opt,name=content_type,json=contentType,proto3,enum=grafeas.v1beta1.attestation.GenericSignedAttestation_ContentType" json:"content_type,omitempty"`
	// The serialized payload that is verified by one or more `signatures`.
	// The encoding and semantic meaning of this payload must match what is set in
	// `content_type`.
	SerializedPayload []byte `protobuf:"bytes,2,opt,name=serialized_payload,json=serializedPayload,proto3" json:"serialized_payload,omitempty"`
	// One or more signatures over `serialized_payload`.  Verifier implementations
	// should consider this attestation message verified if at least one
	// `signature` verifies `serialized_payload`.  See `Signature` in common.proto
	// for more details on signature structure and verification.
	Signatures           []*common_go_proto.Signature `protobuf:"bytes,3,rep,name=signatures,proto3" json:"signatures,omitempty"`
	XXX_NoUnkeyedLiteral struct{}                     `json:"-"`
	XXX_unrecognized     []byte                       `json:"-"`
	XXX_sizecache        int32                        `json:"-"`
}

func (m *GenericSignedAttestation) Reset()         { *m = GenericSignedAttestation{} }
func (m *GenericSignedAttestation) String() string { return proto.CompactTextString(m) }
func (*GenericSignedAttestation) ProtoMessage()    {}
func (*GenericSignedAttestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{1}
}

func (m *GenericSignedAttestation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_GenericSignedAttestation.Unmarshal(m, b)
}
func (m *GenericSignedAttestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_GenericSignedAttestation.Marshal(b, m, deterministic)
}
func (m *GenericSignedAttestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_GenericSignedAttestation.Merge(m, src)
}
func (m *GenericSignedAttestation) XXX_Size() int {
	return xxx_messageInfo_GenericSignedAttestation.Size(m)
}
func (m *GenericSignedAttestation) XXX_DiscardUnknown() {
	xxx_messageInfo_GenericSignedAttestation.DiscardUnknown(m)
}

var xxx_messageInfo_GenericSignedAttestation proto.InternalMessageInfo

func (m *GenericSignedAttestation) GetContentType() GenericSignedAttestation_ContentType {
	if m != nil {
		return m.ContentType
	}
	return GenericSignedAttestation_CONTENT_TYPE_UNSPECIFIED
}

func (m *GenericSignedAttestation) GetSerializedPayload() []byte {
	if m != nil {
		return m.SerializedPayload
	}
	return nil
}

func (m *GenericSignedAttestation) GetSignatures() []*common_go_proto.Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

// Note kind that represents a logical attestation "role" or "authority". For
// example, an organization might have one `Authority` for "QA" and one for
// "build". This note is intended to act strictly as a grouping mechanism for
// the attached occurrences (Attestations). This grouping mechanism also
// provides a security boundary, since IAM ACLs gate the ability for a principle
// to attach an occurrence to a given note. It also provides a single point of
// lookup to find all attached attestation occurrences, even if they don't all
// live in the same project.
type Authority struct {
	// Hint hints at the purpose of the attestation authority.
	Hint                 *Authority_Hint `protobuf:"bytes,1,opt,name=hint,proto3" json:"hint,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Authority) Reset()         { *m = Authority{} }
func (m *Authority) String() string { return proto.CompactTextString(m) }
func (*Authority) ProtoMessage()    {}
func (*Authority) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{2}
}

func (m *Authority) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Authority.Unmarshal(m, b)
}
func (m *Authority) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Authority.Marshal(b, m, deterministic)
}
func (m *Authority) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authority.Merge(m, src)
}
func (m *Authority) XXX_Size() int {
	return xxx_messageInfo_Authority.Size(m)
}
func (m *Authority) XXX_DiscardUnknown() {
	xxx_messageInfo_Authority.DiscardUnknown(m)
}

var xxx_messageInfo_Authority proto.InternalMessageInfo

func (m *Authority) GetHint() *Authority_Hint {
	if m != nil {
		return m.Hint
	}
	return nil
}

// This submessage provides human-readable hints about the purpose of the
// authority. Because the name of a note acts as its resource reference, it is
// important to disambiguate the canonical name of the Note (which might be a
// UUID for security purposes) from "readable" names more suitable for debug
// output. Note that these hints should not be used to look up authorities in
// security sensitive contexts, such as when looking up attestations to
// verify.
type Authority_Hint struct {
	// Required. The human readable name of this attestation authority, for
	// example "qa".
	HumanReadableName    string   `protobuf:"bytes,1,opt,name=human_readable_name,json=humanReadableName,proto3" json:"human_readable_name,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Authority_Hint) Reset()         { *m = Authority_Hint{} }
func (m *Authority_Hint) String() string { return proto.CompactTextString(m) }
func (*Authority_Hint) ProtoMessage()    {}
func (*Authority_Hint) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{2, 0}
}

func (m *Authority_Hint) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Authority_Hint.Unmarshal(m, b)
}
func (m *Authority_Hint) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Authority_Hint.Marshal(b, m, deterministic)
}
func (m *Authority_Hint) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Authority_Hint.Merge(m, src)
}
func (m *Authority_Hint) XXX_Size() int {
	return xxx_messageInfo_Authority_Hint.Size(m)
}
func (m *Authority_Hint) XXX_DiscardUnknown() {
	xxx_messageInfo_Authority_Hint.DiscardUnknown(m)
}

var xxx_messageInfo_Authority_Hint proto.InternalMessageInfo

func (m *Authority_Hint) GetHumanReadableName() string {
	if m != nil {
		return m.HumanReadableName
	}
	return ""
}

// Details of an attestation occurrence.
type Details struct {
	// Required. Attestation for the resource.
	Attestation          *Attestation `protobuf:"bytes,1,opt,name=attestation,proto3" json:"attestation,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Details) Reset()         { *m = Details{} }
func (m *Details) String() string { return proto.CompactTextString(m) }
func (*Details) ProtoMessage()    {}
func (*Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{3}
}

func (m *Details) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Details.Unmarshal(m, b)
}
func (m *Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Details.Marshal(b, m, deterministic)
}
func (m *Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Details.Merge(m, src)
}
func (m *Details) XXX_Size() int {
	return xxx_messageInfo_Details.Size(m)
}
func (m *Details) XXX_DiscardUnknown() {
	xxx_messageInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_Details proto.InternalMessageInfo

func (m *Details) GetAttestation() *Attestation {
	if m != nil {
		return m.Attestation
	}
	return nil
}

// Occurrence that represents a single "attestation". The authenticity of an
// attestation can be verified using the attached signature. If the verifier
// trusts the public key of the signer, then verifying the signature is
// sufficient to establish trust. In this circumstance, the authority to which
// this attestation is attached is primarily useful for look-up (how to find
// this attestation if you already know the authority and artifact to be
// verified) and intent (which authority was this attestation intended to sign
// for).
type Attestation struct {
	// Required. The signature, generally over the `resource_url`, that verifies
	// this attestation. The semantics of the signature veracity are ultimately
	// determined by the verification engine.
	//
	// Types that are valid to be assigned to Signature:
	//	*Attestation_PgpSignedAttestation
	//	*Attestation_GenericSignedAttestation
	Signature            isAttestation_Signature `protobuf_oneof:"signature"`
	XXX_NoUnkeyedLiteral struct{}                `json:"-"`
	XXX_unrecognized     []byte                  `json:"-"`
	XXX_sizecache        int32                   `json:"-"`
}

func (m *Attestation) Reset()         { *m = Attestation{} }
func (m *Attestation) String() string { return proto.CompactTextString(m) }
func (*Attestation) ProtoMessage()    {}
func (*Attestation) Descriptor() ([]byte, []int) {
	return fileDescriptor_84cfb87a442e631e, []int{4}
}

func (m *Attestation) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Attestation.Unmarshal(m, b)
}
func (m *Attestation) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Attestation.Marshal(b, m, deterministic)
}
func (m *Attestation) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Attestation.Merge(m, src)
}
func (m *Attestation) XXX_Size() int {
	return xxx_messageInfo_Attestation.Size(m)
}
func (m *Attestation) XXX_DiscardUnknown() {
	xxx_messageInfo_Attestation.DiscardUnknown(m)
}

var xxx_messageInfo_Attestation proto.InternalMessageInfo

type isAttestation_Signature interface {
	isAttestation_Signature()
}

type Attestation_PgpSignedAttestation struct {
	PgpSignedAttestation *PgpSignedAttestation `protobuf:"bytes,1,opt,name=pgp_signed_attestation,json=pgpSignedAttestation,proto3,oneof"`
}

type Attestation_GenericSignedAttestation struct {
	GenericSignedAttestation *GenericSignedAttestation `protobuf:"bytes,2,opt,name=generic_signed_attestation,json=genericSignedAttestation,proto3,oneof"`
}

func (*Attestation_PgpSignedAttestation) isAttestation_Signature() {}

func (*Attestation_GenericSignedAttestation) isAttestation_Signature() {}

func (m *Attestation) GetSignature() isAttestation_Signature {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *Attestation) GetPgpSignedAttestation() *PgpSignedAttestation {
	if x, ok := m.GetSignature().(*Attestation_PgpSignedAttestation); ok {
		return x.PgpSignedAttestation
	}
	return nil
}

func (m *Attestation) GetGenericSignedAttestation() *GenericSignedAttestation {
	if x, ok := m.GetSignature().(*Attestation_GenericSignedAttestation); ok {
		return x.GenericSignedAttestation
	}
	return nil
}

// XXX_OneofWrappers is for the internal use of the proto package.
func (*Attestation) XXX_OneofWrappers() []interface{} {
	return []interface{}{
		(*Attestation_PgpSignedAttestation)(nil),
		(*Attestation_GenericSignedAttestation)(nil),
	}
}

func init() {
	proto.RegisterEnum("grafeas.v1beta1.attestation.PgpSignedAttestation_ContentType", PgpSignedAttestation_ContentType_name, PgpSignedAttestation_ContentType_value)
	proto.RegisterEnum("grafeas.v1beta1.attestation.GenericSignedAttestation_ContentType", GenericSignedAttestation_ContentType_name, GenericSignedAttestation_ContentType_value)
	proto.RegisterType((*PgpSignedAttestation)(nil), "grafeas.v1beta1.attestation.PgpSignedAttestation")
	proto.RegisterType((*GenericSignedAttestation)(nil), "grafeas.v1beta1.attestation.GenericSignedAttestation")
	proto.RegisterType((*Authority)(nil), "grafeas.v1beta1.attestation.Authority")
	proto.RegisterType((*Authority_Hint)(nil), "grafeas.v1beta1.attestation.Authority.Hint")
	proto.RegisterType((*Details)(nil), "grafeas.v1beta1.attestation.Details")
	proto.RegisterType((*Attestation)(nil), "grafeas.v1beta1.attestation.Attestation")
}

func init() { proto.RegisterFile("proto/v1beta1/attestation.proto", fileDescriptor_84cfb87a442e631e) }

var fileDescriptor_84cfb87a442e631e = []byte{
	// 530 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xac, 0x54, 0xcb, 0x6e, 0xd3, 0x40,
	0x14, 0x8d, 0x93, 0xaa, 0x34, 0xd7, 0x15, 0x6a, 0xa7, 0x15, 0x58, 0xa1, 0x2a, 0x91, 0x57, 0x91,
	0x10, 0x8e, 0x12, 0x04, 0x0b, 0xa4, 0x0a, 0xe5, 0x45, 0xe2, 0x02, 0xae, 0x35, 0x4e, 0x17, 0xb0,
	0x19, 0x26, 0xf1, 0x30, 0x19, 0x11, 0x3f, 0x64, 0x4f, 0x90, 0xcc, 0x1a, 0xf1, 0x21, 0xfc, 0x01,
	0xff, 0xc7, 0x02, 0xc5, 0x79, 0x19, 0x92, 0x58, 0x02, 0x75, 0x65, 0x8f, 0xcf, 0x3d, 0x73, 0xee,
	0xb9, 0x73, 0xc6, 0xf0, 0x38, 0x8c, 0x02, 0x19, 0xd4, 0xbf, 0x34, 0x46, 0x4c, 0xd2, 0x46, 0x9d,
	0x4a, 0xc9, 0x62, 0x49, 0xa5, 0x08, 0x7c, 0x23, 0x45, 0xd0, 0x23, 0x1e, 0xd1, 0x4f, 0x8c, 0xc6,
	0xc6, 0xb2, 0xc4, 0xc8, 0x94, 0x54, 0x2a, 0x7f, 0xb2, 0xc7, 0x81, 0xe7, 0xad, 0x88, 0xfa, 0xf7,
	0x22, 0x9c, 0xdb, 0x3c, 0x74, 0x04, 0xf7, 0x99, 0xdb, 0xda, 0x90, 0xd0, 0x05, 0x94, 0x63, 0xc1,
	0x7d, 0x2a, 0x67, 0x11, 0xd3, 0x94, 0xaa, 0x52, 0x2b, 0xe3, 0xcd, 0x07, 0xf4, 0x11, 0x8e, 0xc7,
	0x81, 0x2f, 0x99, 0x2f, 0x89, 0x4c, 0x42, 0xa6, 0x95, 0xaa, 0x4a, 0xed, 0x7e, 0xf3, 0xca, 0xc8,
	0x69, 0xc3, 0xd8, 0x25, 0x63, 0x74, 0x16, 0xbb, 0x0c, 0x93, 0x90, 0x61, 0x75, 0xbc, 0x59, 0xa0,
	0x4b, 0x80, 0x90, 0x87, 0xe4, 0x33, 0x4b, 0x88, 0x70, 0xb5, 0xe2, 0xbc, 0x81, 0x41, 0x01, 0x1f,
	0x85, 0x3c, 0x7c, 0xc3, 0x12, 0xd3, 0xd5, 0xbb, 0xa0, 0x66, 0xb8, 0xe8, 0x02, 0xb4, 0xce, 0x8d,
	0x35, 0xec, 0x59, 0x43, 0x32, 0x7c, 0x6f, 0xf7, 0xc8, 0xad, 0xe5, 0xd8, 0xbd, 0x8e, 0xf9, 0xda,
	0xec, 0x75, 0x4f, 0x0a, 0xe8, 0x21, 0x9c, 0x39, 0xe6, 0x3b, 0xfb, 0x6d, 0x8f, 0x38, 0x66, 0xdf,
	0x32, 0xad, 0x3e, 0xb9, 0x76, 0x6e, 0xac, 0x13, 0xa5, 0x7d, 0x04, 0x87, 0x0b, 0x05, 0xfd, 0x67,
	0x11, 0xb4, 0x3e, 0xf3, 0x59, 0x24, 0xc6, 0xdb, 0xc3, 0x70, 0xff, 0xb2, 0xab, 0xa4, 0x76, 0x5b,
	0xb9, 0x76, 0xf7, 0x6d, 0xb6, 0xdf, 0xf2, 0x53, 0x40, 0x31, 0x8b, 0x04, 0x9d, 0x8a, 0xaf, 0xcc,
	0x25, 0x21, 0x4d, 0xa6, 0x01, 0x5d, 0x58, 0x3f, 0xc6, 0xa7, 0x1b, 0xc4, 0x5e, 0x00, 0xe8, 0x25,
	0xc0, 0xfa, 0x40, 0x62, 0xad, 0x54, 0x2d, 0xd5, 0xd4, 0x66, 0x65, 0xab, 0x25, 0x67, 0x55, 0x82,
	0x33, 0xd5, 0x77, 0x33, 0x3d, 0xfd, 0x9b, 0x02, 0xe5, 0xd6, 0x4c, 0x4e, 0x82, 0x48, 0xc8, 0x04,
	0xbd, 0x82, 0x83, 0x89, 0xf0, 0x65, 0x3a, 0x1c, 0xb5, 0xf9, 0x24, 0x77, 0x38, 0x6b, 0x96, 0x31,
	0x10, 0xbe, 0xc4, 0x29, 0xb1, 0xf2, 0x02, 0x0e, 0xe6, 0x2b, 0x64, 0xc0, 0xd9, 0x64, 0xe6, 0x51,
	0x9f, 0x44, 0x8c, 0xba, 0x74, 0x34, 0x65, 0xc4, 0xa7, 0xde, 0x2a, 0x84, 0xa7, 0x29, 0x84, 0x97,
	0x88, 0x45, 0x3d, 0xa6, 0xdf, 0xc2, 0xbd, 0x2e, 0x93, 0x54, 0x4c, 0x63, 0x74, 0x0d, 0x6a, 0x46,
	0x66, 0xd9, 0x4a, 0x2d, 0xbf, 0x95, 0xcd, 0x3b, 0xce, 0x92, 0xf5, 0x5f, 0x0a, 0xa8, 0xd9, 0x10,
	0x08, 0x78, 0x30, 0x4f, 0x64, 0x9c, 0x1e, 0x28, 0xd9, 0x96, 0x69, 0xfc, 0x73, 0xfa, 0x07, 0x05,
	0x7c, 0x1e, 0xee, 0xba, 0x7c, 0x33, 0xa8, 0xf0, 0x45, 0x7c, 0x76, 0xc9, 0x15, 0x53, 0xb9, 0xe7,
	0xff, 0x95, 0xbe, 0x41, 0x01, 0x6b, 0x7c, 0x0f, 0xd6, 0x56, 0x33, 0x77, 0xbe, 0xcd, 0xe1, 0x52,
	0x04, 0x79, 0x1a, 0xb6, 0xf2, 0xe1, 0x8a, 0x0b, 0x39, 0x99, 0x8d, 0x8c, 0x71, 0xe0, 0xd5, 0x97,
	0x95, 0xeb, 0xe7, 0xde, 0x5f, 0x16, 0xe1, 0x01, 0x49, 0xc1, 0x1f, 0xc5, 0x52, 0x1f, 0xb7, 0x46,
	0x87, 0xe9, 0xe2, 0xd9, 0xef, 0x00, 0x00, 0x00, 0xff, 0xff, 0x41, 0xf3, 0x71, 0x4a, 0xe5, 0x04,
	0x00, 0x00,
}
