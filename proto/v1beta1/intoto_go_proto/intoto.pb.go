// Code generated by protoc-gen-go. DO NOT EDIT.
// source: intoto.proto

package intoto_go_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	_struct "github.com/golang/protobuf/ptypes/struct"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// This contains the fields corresponding to the definition of a software supply
// chain step in an in-toto layout. This information goes into a Grafeas note.
type InToto struct {
	// This field identifies the name of the step in the supply chain.
	StepName string `protobuf:"bytes,1,opt,name=step_name,json=stepName,proto3" json:"step_name,omitempty"`
	// This field contains the public keys that can be used to verify the
	// signatures on the step metadata.
	SigningKeys []*SigningKey `protobuf:"bytes,2,rep,name=signing_keys,json=signingKeys,proto3" json:"signing_keys,omitempty"`
	// The following fields contain in-toto artifact rules identifying the
	// artifacts that enter this supply chain step, and exit the supply chain
	// step, i.e. materials and products of the step.
	ExpectedMaterials []*_struct.ListValue `protobuf:"bytes,3,rep,name=expected_materials,json=expectedMaterials,proto3" json:"expected_materials,omitempty"`
	ExpectedProducts  []*_struct.ListValue `protobuf:"bytes,4,rep,name=expected_products,json=expectedProducts,proto3" json:"expected_products,omitempty"`
	// This field contains the expected command used to perform the step.
	ExpectedCommand []string `protobuf:"bytes,5,rep,name=expected_command,json=expectedCommand,proto3" json:"expected_command,omitempty"`
	// This field contains a value that indicates the minimum number of keys that
	// need to be used to sign the step's in-toto link.
	Threshold            int64    `protobuf:"varint,6,opt,name=threshold,proto3" json:"threshold,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *InToto) Reset()         { *m = InToto{} }
func (m *InToto) String() string { return proto.CompactTextString(m) }
func (*InToto) ProtoMessage()    {}
func (*InToto) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{0}
}

func (m *InToto) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_InToto.Unmarshal(m, b)
}
func (m *InToto) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_InToto.Marshal(b, m, deterministic)
}
func (m *InToto) XXX_Merge(src proto.Message) {
	xxx_messageInfo_InToto.Merge(m, src)
}
func (m *InToto) XXX_Size() int {
	return xxx_messageInfo_InToto.Size(m)
}
func (m *InToto) XXX_DiscardUnknown() {
	xxx_messageInfo_InToto.DiscardUnknown(m)
}

var xxx_messageInfo_InToto proto.InternalMessageInfo

func (m *InToto) GetStepName() string {
	if m != nil {
		return m.StepName
	}
	return ""
}

func (m *InToto) GetSigningKeys() []*SigningKey {
	if m != nil {
		return m.SigningKeys
	}
	return nil
}

func (m *InToto) GetExpectedMaterials() []*_struct.ListValue {
	if m != nil {
		return m.ExpectedMaterials
	}
	return nil
}

func (m *InToto) GetExpectedProducts() []*_struct.ListValue {
	if m != nil {
		return m.ExpectedProducts
	}
	return nil
}

func (m *InToto) GetExpectedCommand() []string {
	if m != nil {
		return m.ExpectedCommand
	}
	return nil
}

func (m *InToto) GetThreshold() int64 {
	if m != nil {
		return m.Threshold
	}
	return 0
}

// This defines the format used to record keys used in the software supply
// chain. An in-toto link is attested using one or more keys defined in the
// in-toto layout.
type SigningKey struct {
	// key_id is an identifier for the signing key.
	KeyId string `protobuf:"bytes,1,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// This field identifies the hash algorithms used in the particular key ID.
	KeyIdHashAlgorithms []string `protobuf:"bytes,2,rep,name=key_id_hash_algorithms,json=keyIdHashAlgorithms,proto3" json:"key_id_hash_algorithms,omitempty"`
	// This field identifies the specific signing method. Eg: "RSASSA-PSS",
	// "ed25519", and "ecdsa".
	KeyType string `protobuf:"bytes,3,opt,name=key_type,json=keyType,proto3" json:"key_type,omitempty"`
	// This field contains the actual public key.
	PublicKeyValue string `protobuf:"bytes,4,opt,name=public_key_value,json=publicKeyValue,proto3" json:"public_key_value,omitempty"`
	// This field contains the overall scheme used for the creation of the signing
	// key. Eg: "rsassa-pss-sha256".
	KeyScheme            string   `protobuf:"bytes,5,opt,name=key_scheme,json=keyScheme,proto3" json:"key_scheme,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *SigningKey) Reset()         { *m = SigningKey{} }
func (m *SigningKey) String() string { return proto.CompactTextString(m) }
func (*SigningKey) ProtoMessage()    {}
func (*SigningKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{1}
}

func (m *SigningKey) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_SigningKey.Unmarshal(m, b)
}
func (m *SigningKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_SigningKey.Marshal(b, m, deterministic)
}
func (m *SigningKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_SigningKey.Merge(m, src)
}
func (m *SigningKey) XXX_Size() int {
	return xxx_messageInfo_SigningKey.Size(m)
}
func (m *SigningKey) XXX_DiscardUnknown() {
	xxx_messageInfo_SigningKey.DiscardUnknown(m)
}

var xxx_messageInfo_SigningKey proto.InternalMessageInfo

func (m *SigningKey) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *SigningKey) GetKeyIdHashAlgorithms() []string {
	if m != nil {
		return m.KeyIdHashAlgorithms
	}
	return nil
}

func (m *SigningKey) GetKeyType() string {
	if m != nil {
		return m.KeyType
	}
	return ""
}

func (m *SigningKey) GetPublicKeyValue() string {
	if m != nil {
		return m.PublicKeyValue
	}
	return ""
}

func (m *SigningKey) GetKeyScheme() string {
	if m != nil {
		return m.KeyScheme
	}
	return ""
}

// This corresponds to a signed in-toto link - it is made up of one or more
// signatures and the in-toto link itself. This is used for occurrences of a
// Grafeas in-toto note.
type Details struct {
	Signatures           []*Signature `protobuf:"bytes,1,rep,name=signatures,proto3" json:"signatures,omitempty"`
	Link                 *Link        `protobuf:"bytes,2,opt,name=link,json=signed,proto3" json:"link,omitempty"`
	XXX_NoUnkeyedLiteral struct{}     `json:"-"`
	XXX_unrecognized     []byte       `json:"-"`
	XXX_sizecache        int32        `json:"-"`
}

func (m *Details) Reset()         { *m = Details{} }
func (m *Details) String() string { return proto.CompactTextString(m) }
func (*Details) ProtoMessage()    {}
func (*Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{2}
}

func (m *Details) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Details.Unmarshal(m, b)
}
func (m *Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Details.Marshal(b, m, deterministic)
}
func (m *Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Details.Merge(m, src)
}
func (m *Details) XXX_Size() int {
	return xxx_messageInfo_Details.Size(m)
}
func (m *Details) XXX_DiscardUnknown() {
	xxx_messageInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_Details proto.InternalMessageInfo

func (m *Details) GetSignatures() []*Signature {
	if m != nil {
		return m.Signatures
	}
	return nil
}

func (m *Details) GetLink() *Link {
	if m != nil {
		return m.Link
	}
	return nil
}

// A signature object consists of the KeyID used and the signature itself.
type Signature struct {
	KeyId                string   `protobuf:"bytes,1,opt,name=key_id,json=keyid,proto3" json:"key_id,omitempty"`
	Signature            string   `protobuf:"bytes,2,opt,name=signature,json=sig,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Signature) Reset()         { *m = Signature{} }
func (m *Signature) String() string { return proto.CompactTextString(m) }
func (*Signature) ProtoMessage()    {}
func (*Signature) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{3}
}

func (m *Signature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Signature.Unmarshal(m, b)
}
func (m *Signature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Signature.Marshal(b, m, deterministic)
}
func (m *Signature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Signature.Merge(m, src)
}
func (m *Signature) XXX_Size() int {
	return xxx_messageInfo_Signature.Size(m)
}
func (m *Signature) XXX_DiscardUnknown() {
	xxx_messageInfo_Signature.DiscardUnknown(m)
}

var xxx_messageInfo_Signature proto.InternalMessageInfo

func (m *Signature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *Signature) GetSignature() string {
	if m != nil {
		return m.Signature
	}
	return ""
}

// This corresponds to an in-toto link.
type Link struct {
	// This field contains the full command executed for the step. This can also
	// be empty if links are generated for operations that aren't directly mapped
	// to a specific command. Each term in the command is an independent string
	// in the list. An example of a command in the in-toto metadata field is:
	// "command": ["git", "clone", "https://github.com/in-toto/demo-project.git"]
	EffectiveCommand []string `protobuf:"bytes,1,rep,name=effective_command,json=command,proto3" json:"effective_command,omitempty"`
	// Materials are the supply chain artifacts that go into the step and are used
	// for the operation performed. The key of the map is the path of the artifact
	// and the structure contains the recorded hash information. An example is:
	// "materials": {
	//   "foo/bar": {
	//     "sha256": "ebebf..."
	//   }
	// }
	Materials map[string]*Link_ArtifactHashObject `protobuf:"bytes,2,rep,name=materials,proto3" json:"materials,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// Products are the supply chain artifacts generated as a result of the step.
	// The structure is identical to that of materials.
	Products map[string]*Link_ArtifactHashObject `protobuf:"bytes,3,rep,name=products,proto3" json:"products,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// By Products are data generated as part of a software supply chain step, but
	// are not the actual result of the step. The suggested fields are "stderr",
	// "stdout", and "return-value".
	Byproducts map[string]*_struct.Struct `protobuf:"bytes,4,rep,name=byproducts,proto3" json:"byproducts,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	// This is a field that can be used to capture information about the
	// environment. It is suggested for this field to contain information that
	// details environment variables, filesystem information, and the present
	// working directory. The recommended structure of this field is:
	// "environment": {
	//   "variables": "<ENV>",
	//   "filesystem": "<FS>",
	//   "workdir": "<CWD>",
	//   "<ANY OTHER RELEVANT FIELDS>": "..."
	// }
	Environment          map[string]*_struct.Struct `protobuf:"bytes,5,rep,name=environment,proto3" json:"environment,omitempty" protobuf_key:"bytes,1,opt,name=key,proto3" protobuf_val:"bytes,2,opt,name=value,proto3"`
	XXX_NoUnkeyedLiteral struct{}                   `json:"-"`
	XXX_unrecognized     []byte                     `json:"-"`
	XXX_sizecache        int32                      `json:"-"`
}

func (m *Link) Reset()         { *m = Link{} }
func (m *Link) String() string { return proto.CompactTextString(m) }
func (*Link) ProtoMessage()    {}
func (*Link) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4}
}

func (m *Link) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link.Unmarshal(m, b)
}
func (m *Link) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link.Marshal(b, m, deterministic)
}
func (m *Link) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link.Merge(m, src)
}
func (m *Link) XXX_Size() int {
	return xxx_messageInfo_Link.Size(m)
}
func (m *Link) XXX_DiscardUnknown() {
	xxx_messageInfo_Link.DiscardUnknown(m)
}

var xxx_messageInfo_Link proto.InternalMessageInfo

func (m *Link) GetEffectiveCommand() []string {
	if m != nil {
		return m.EffectiveCommand
	}
	return nil
}

func (m *Link) GetMaterials() map[string]*Link_ArtifactHashObject {
	if m != nil {
		return m.Materials
	}
	return nil
}

func (m *Link) GetProducts() map[string]*Link_ArtifactHashObject {
	if m != nil {
		return m.Products
	}
	return nil
}

func (m *Link) GetByproducts() map[string]*_struct.Struct {
	if m != nil {
		return m.Byproducts
	}
	return nil
}

func (m *Link) GetEnvironment() map[string]*_struct.Struct {
	if m != nil {
		return m.Environment
	}
	return nil
}

// Defines a hash object for use in Materials and Products.
type Link_ArtifactHashObject struct {
	Sha256               string   `protobuf:"bytes,1,opt,name=sha256,proto3" json:"sha256,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Link_ArtifactHashObject) Reset()         { *m = Link_ArtifactHashObject{} }
func (m *Link_ArtifactHashObject) String() string { return proto.CompactTextString(m) }
func (*Link_ArtifactHashObject) ProtoMessage()    {}
func (*Link_ArtifactHashObject) Descriptor() ([]byte, []int) {
	return fileDescriptor_1442eade79a66571, []int{4, 0}
}

func (m *Link_ArtifactHashObject) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Link_ArtifactHashObject.Unmarshal(m, b)
}
func (m *Link_ArtifactHashObject) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Link_ArtifactHashObject.Marshal(b, m, deterministic)
}
func (m *Link_ArtifactHashObject) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Link_ArtifactHashObject.Merge(m, src)
}
func (m *Link_ArtifactHashObject) XXX_Size() int {
	return xxx_messageInfo_Link_ArtifactHashObject.Size(m)
}
func (m *Link_ArtifactHashObject) XXX_DiscardUnknown() {
	xxx_messageInfo_Link_ArtifactHashObject.DiscardUnknown(m)
}

var xxx_messageInfo_Link_ArtifactHashObject proto.InternalMessageInfo

func (m *Link_ArtifactHashObject) GetSha256() string {
	if m != nil {
		return m.Sha256
	}
	return ""
}

func init() {
	proto.RegisterType((*InToto)(nil), "grafeas.v1beta1.intoto.InToto")
	proto.RegisterType((*SigningKey)(nil), "grafeas.v1beta1.intoto.SigningKey")
	proto.RegisterType((*Details)(nil), "grafeas.v1beta1.intoto.Details")
	proto.RegisterType((*Signature)(nil), "grafeas.v1beta1.intoto.Signature")
	proto.RegisterType((*Link)(nil), "grafeas.v1beta1.intoto.Link")
	proto.RegisterMapType((map[string]*_struct.Struct)(nil), "grafeas.v1beta1.intoto.Link.ByproductsEntry")
	proto.RegisterMapType((map[string]*_struct.Struct)(nil), "grafeas.v1beta1.intoto.Link.EnvironmentEntry")
	proto.RegisterMapType((map[string]*Link_ArtifactHashObject)(nil), "grafeas.v1beta1.intoto.Link.MaterialsEntry")
	proto.RegisterMapType((map[string]*Link_ArtifactHashObject)(nil), "grafeas.v1beta1.intoto.Link.ProductsEntry")
	proto.RegisterType((*Link_ArtifactHashObject)(nil), "grafeas.v1beta1.intoto.Link.ArtifactHashObject")
}

func init() { proto.RegisterFile("intoto.proto", fileDescriptor_1442eade79a66571) }

var fileDescriptor_1442eade79a66571 = []byte{
	// 713 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xb4, 0x54, 0xcd, 0x6e, 0xf3, 0x44,
	0x14, 0x95, 0xe3, 0x24, 0xad, 0x6f, 0x3e, 0xbe, 0x2f, 0xdf, 0x20, 0x82, 0x1b, 0x8a, 0x14, 0xb2,
	0x0a, 0xd0, 0x3a, 0x6a, 0x2a, 0x50, 0xd5, 0x5d, 0x0a, 0xa1, 0x44, 0x2d, 0xb4, 0x72, 0xab, 0x22,
	0x21, 0x21, 0x6b, 0x62, 0xdf, 0xd8, 0x83, 0xff, 0x22, 0xcf, 0x24, 0xc2, 0x3b, 0x1e, 0x83, 0x35,
	0xcf, 0xc1, 0x0b, 0xf0, 0x56, 0xc8, 0x33, 0x8e, 0x93, 0xfe, 0x85, 0x0d, 0xac, 0xec, 0x39, 0x3e,
	0xe7, 0xdc, 0xb9, 0xf7, 0x1e, 0x19, 0xde, 0xb0, 0x44, 0xa4, 0x22, 0xb5, 0x16, 0x59, 0x2a, 0x52,
	0xd2, 0xf1, 0x33, 0x3a, 0x47, 0xca, 0xad, 0xd5, 0xc9, 0x0c, 0x05, 0x3d, 0xb1, 0xd4, 0xd7, 0xee,
	0xa1, 0x9f, 0xa6, 0x7e, 0x84, 0x43, 0xc9, 0x9a, 0x2d, 0xe7, 0x43, 0x2e, 0xb2, 0xa5, 0x2b, 0x94,
	0xaa, 0xff, 0x77, 0x0d, 0x9a, 0xd3, 0xe4, 0xbe, 0x30, 0xf8, 0x04, 0x0c, 0x2e, 0x70, 0xe1, 0x24,
	0x34, 0x46, 0x53, 0xeb, 0x69, 0x03, 0xc3, 0xde, 0x2f, 0x80, 0x1f, 0x69, 0x8c, 0x64, 0x02, 0x6f,
	0x38, 0xf3, 0x13, 0x96, 0xf8, 0x4e, 0x88, 0x39, 0x37, 0x6b, 0x3d, 0x7d, 0xd0, 0x1a, 0xf5, 0xad,
	0x97, 0x8b, 0x5a, 0x77, 0x8a, 0x7b, 0x85, 0xb9, 0xdd, 0xe2, 0xd5, 0x3b, 0x27, 0x53, 0x20, 0xf8,
	0xdb, 0x02, 0x5d, 0x81, 0x9e, 0x13, 0x53, 0x81, 0x19, 0xa3, 0x11, 0x37, 0x75, 0x69, 0xd6, 0xb5,
	0xd4, 0x4d, 0xad, 0xf5, 0x4d, 0xad, 0x6b, 0xc6, 0xc5, 0x03, 0x8d, 0x96, 0x68, 0xbf, 0x5f, 0xab,
	0x7e, 0x58, 0x8b, 0xc8, 0x25, 0x54, 0xa0, 0xb3, 0xc8, 0x52, 0x6f, 0xe9, 0x0a, 0x6e, 0xd6, 0xff,
	0xd5, 0xa9, 0xbd, 0x16, 0xdd, 0x96, 0x1a, 0xf2, 0x39, 0x54, 0x98, 0xe3, 0xa6, 0x71, 0x4c, 0x13,
	0xcf, 0x6c, 0xf4, 0xf4, 0x81, 0x61, 0xbf, 0x5b, 0xe3, 0xdf, 0x28, 0x98, 0x1c, 0x82, 0x21, 0x82,
	0x0c, 0x79, 0x90, 0x46, 0x9e, 0xd9, 0xec, 0x69, 0x03, 0xdd, 0xde, 0x00, 0xfd, 0xbf, 0x34, 0x80,
	0x4d, 0xe3, 0xe4, 0x23, 0x68, 0x86, 0x98, 0x3b, 0xcc, 0x2b, 0x87, 0xd9, 0x08, 0x31, 0x9f, 0x7a,
	0xe4, 0x14, 0x3a, 0x0a, 0x76, 0x02, 0xca, 0x03, 0x87, 0x46, 0x7e, 0x9a, 0x31, 0x11, 0xc4, 0x6a,
	0xa6, 0x86, 0xfd, 0xa1, 0xa4, 0x7d, 0x4f, 0x79, 0x30, 0xae, 0x3e, 0x91, 0x03, 0xd8, 0x2f, 0x44,
	0x22, 0x5f, 0xa0, 0xa9, 0x4b, 0xb7, 0xbd, 0x10, 0xf3, 0xfb, 0x7c, 0x81, 0x64, 0x00, 0xed, 0xc5,
	0x72, 0x16, 0x31, 0xb7, 0x58, 0x8c, 0xb3, 0x2a, 0x9a, 0x34, 0xeb, 0x92, 0xf2, 0x56, 0xe1, 0x57,
	0x98, 0xcb, 0xd6, 0xc9, 0xa7, 0x00, 0x05, 0x85, 0xbb, 0x01, 0xc6, 0x68, 0x36, 0x24, 0xc7, 0x08,
	0x31, 0xbf, 0x93, 0x40, 0xff, 0x77, 0x0d, 0xf6, 0xbe, 0x45, 0x41, 0x59, 0xc4, 0xc9, 0x18, 0xa0,
	0x58, 0x1b, 0x15, 0xcb, 0x0c, 0xb9, 0xa9, 0xc9, 0xa9, 0x7e, 0xb6, 0x6b, 0xd9, 0x92, 0x69, 0x6f,
	0x89, 0xc8, 0x08, 0xea, 0x11, 0x4b, 0x42, 0xb3, 0xd6, 0xd3, 0x06, 0xad, 0xd1, 0xe1, 0x6b, 0xe2,
	0x6b, 0x96, 0x84, 0x76, 0xb3, 0xd0, 0xa1, 0xd7, 0x3f, 0x07, 0xa3, 0x32, 0x7b, 0x71, 0x7e, 0xcc,
	0x23, 0x1d, 0x30, 0xaa, 0x2a, 0xd2, 0xdc, 0xb0, 0x75, 0xce, 0xfc, 0xfe, 0x1f, 0x4d, 0xa8, 0x17,
	0x66, 0xa4, 0x0f, 0xef, 0x71, 0x3e, 0x47, 0x57, 0xb0, 0x15, 0x56, 0x0b, 0xd5, 0xe4, 0x6c, 0xf7,
	0xca, 0x23, 0x99, 0x82, 0xb1, 0x89, 0x9f, 0xca, 0xf2, 0x97, 0xbb, 0x6e, 0x68, 0x55, 0xb9, 0x9b,
	0x24, 0x22, 0xcb, 0xed, 0x8d, 0x9a, 0x7c, 0x07, 0xfb, 0x55, 0xfc, 0x54, 0x90, 0xbf, 0xd8, 0xe9,
	0xb4, 0xce, 0x9d, 0x32, 0xaa, 0xb4, 0xe4, 0x1a, 0x60, 0x96, 0x3f, 0x09, 0xf2, 0xd1, 0x4e, 0xa7,
	0x8b, 0x8a, 0xae, 0xbc, 0xb6, 0xf4, 0xe4, 0x06, 0x5a, 0x98, 0xac, 0x58, 0x96, 0x26, 0x31, 0x26,
	0x42, 0xe6, 0xb9, 0x35, 0x3a, 0xde, 0x69, 0x37, 0xd9, 0xf0, 0x95, 0xdf, 0xb6, 0x43, 0xf7, 0x08,
	0xc8, 0x38, 0x13, 0x6c, 0x4e, 0x5d, 0x51, 0x64, 0xf3, 0x66, 0xf6, 0x2b, 0xba, 0x82, 0x74, 0xa0,
	0xc9, 0x03, 0x3a, 0xfa, 0xea, 0xeb, 0x72, 0x47, 0xe5, 0xa9, 0x1b, 0xc3, 0xdb, 0xc7, 0x13, 0x23,
	0x6d, 0xd0, 0x43, 0xcc, 0x4b, 0x5a, 0xf1, 0x4a, 0x26, 0xd0, 0x50, 0x69, 0x55, 0x09, 0x19, 0xee,
	0xbc, 0xdc, 0xf3, 0xda, 0xb6, 0x52, 0x9f, 0xd7, 0xce, 0xb4, 0x6e, 0x04, 0x1f, 0x3c, 0x1a, 0xeb,
	0xff, 0x5b, 0xed, 0x01, 0xde, 0x3d, 0x19, 0xfd, 0x0b, 0xf5, 0x8e, 0x1f, 0xd7, 0xfb, 0xf8, 0xd9,
	0x2f, 0xe9, 0x4e, 0xfe, 0x86, 0xb7, 0x7d, 0x7f, 0x82, 0xf6, 0xd3, 0x1d, 0xfc, 0x27, 0xc6, 0x17,
	0xbf, 0xc0, 0x01, 0x4b, 0x5f, 0x69, 0xf8, 0x56, 0xfb, 0xf9, 0xcc, 0x67, 0x22, 0x58, 0xce, 0x2c,
	0x37, 0x8d, 0x87, 0x25, 0xa9, 0x7a, 0x4a, 0xd7, 0x61, 0x29, 0x19, 0x2a, 0x89, 0xe3, 0xa7, 0x8e,
	0xc4, 0xff, 0xac, 0xe9, 0x97, 0xf6, 0x78, 0xd6, 0x94, 0x87, 0xd3, 0x7f, 0x02, 0x00, 0x00, 0xff,
	0xff, 0x30, 0x1f, 0x23, 0xaa, 0x90, 0x06, 0x00, 0x00,
}
