// Code generated by protoc-gen-go. DO NOT EDIT.
// source: proto/v1/build.proto

package build_go_proto

import (
	fmt "fmt"
	proto "github.com/golang/protobuf/proto"
	provenance_go_proto "github.com/grafeas/grafeas/proto/v1/provenance_go_proto"
	math "math"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion3 // please upgrade the proto package

// Public key formats.
type BuildSignature_KeyType int32

const (
	// `KeyType` is not set.
	BuildSignature_KEY_TYPE_UNSPECIFIED BuildSignature_KeyType = 0
	// `PGP ASCII Armored` public key.
	BuildSignature_PGP_ASCII_ARMORED BuildSignature_KeyType = 1
	// `PKIX PEM` public key.
	BuildSignature_PKIX_PEM BuildSignature_KeyType = 2
)

var BuildSignature_KeyType_name = map[int32]string{
	0: "KEY_TYPE_UNSPECIFIED",
	1: "PGP_ASCII_ARMORED",
	2: "PKIX_PEM",
}

var BuildSignature_KeyType_value = map[string]int32{
	"KEY_TYPE_UNSPECIFIED": 0,
	"PGP_ASCII_ARMORED":    1,
	"PKIX_PEM":             2,
}

func (x BuildSignature_KeyType) String() string {
	return proto.EnumName(BuildSignature_KeyType_name, int32(x))
}

func (BuildSignature_KeyType) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_a19bec1b0e925ab2, []int{1, 0}
}

// DO NOT USE: UNDER HEAVY DEVELOPMENT.
// TODO(aysylu): finalize this.
//
// Note holding the version of the provider's builder and the signature of the
// provenance message in the build details occurrence.
type Build struct {
	// Required. Immutable. Version of the builder which produced this build.
	BuilderVersion string `protobuf:"bytes,1,opt,name=builder_version,json=builderVersion,proto3" json:"builder_version,omitempty"`
	// Signature of the build in occurrences pointing to this build note
	// containing build details.
	Signature            *BuildSignature `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	XXX_NoUnkeyedLiteral struct{}        `json:"-"`
	XXX_unrecognized     []byte          `json:"-"`
	XXX_sizecache        int32           `json:"-"`
}

func (m *Build) Reset()         { *m = Build{} }
func (m *Build) String() string { return proto.CompactTextString(m) }
func (*Build) ProtoMessage()    {}
func (*Build) Descriptor() ([]byte, []int) {
	return fileDescriptor_a19bec1b0e925ab2, []int{0}
}

func (m *Build) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Build.Unmarshal(m, b)
}
func (m *Build) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Build.Marshal(b, m, deterministic)
}
func (m *Build) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Build.Merge(m, src)
}
func (m *Build) XXX_Size() int {
	return xxx_messageInfo_Build.Size(m)
}
func (m *Build) XXX_DiscardUnknown() {
	xxx_messageInfo_Build.DiscardUnknown(m)
}

var xxx_messageInfo_Build proto.InternalMessageInfo

func (m *Build) GetBuilderVersion() string {
	if m != nil {
		return m.BuilderVersion
	}
	return ""
}

func (m *Build) GetSignature() *BuildSignature {
	if m != nil {
		return m.Signature
	}
	return nil
}

// Message encapsulating the signature of the verified build.
type BuildSignature struct {
	// Public key of the builder which can be used to verify that the related
	// findings are valid and unchanged. If `key_type` is empty, this defaults
	// to PEM encoded public keys.
	//
	// This field may be empty if `key_id` references an external key.
	//
	// For Cloud Build based signatures, this is a PEM encoded public
	// key. To verify the Cloud Build signature, place the contents of
	// this field into a file (public.pem). The signature field is base64-decoded
	// into its binary representation in signature.bin, and the provenance bytes
	// from `BuildDetails` are base64-decoded into a binary representation in
	// signed.bin. OpenSSL can then verify the signature:
	// `openssl sha256 -verify public.pem -signature signature.bin signed.bin`
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey,proto3" json:"public_key,omitempty"`
	// Required. Signature of the related `BuildProvenance`. In JSON, this is
	// base-64 encoded.
	Signature []byte `protobuf:"bytes,2,opt,name=signature,proto3" json:"signature,omitempty"`
	// An ID for the key used to sign. This could be either an ID for the key
	// stored in `public_key` (such as the ID or fingerprint for a PGP key, or the
	// CN for a cert), or a reference to an external key (such as a reference to a
	// key in Cloud Key Management Service).
	KeyId string `protobuf:"bytes,3,opt,name=key_id,json=keyId,proto3" json:"key_id,omitempty"`
	// The type of the key, either stored in `public_key` or referenced in
	// `key_id`.
	KeyType              BuildSignature_KeyType `protobuf:"varint,4,opt,name=key_type,json=keyType,proto3,enum=grafeas.v1.build.BuildSignature_KeyType" json:"key_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}               `json:"-"`
	XXX_unrecognized     []byte                 `json:"-"`
	XXX_sizecache        int32                  `json:"-"`
}

func (m *BuildSignature) Reset()         { *m = BuildSignature{} }
func (m *BuildSignature) String() string { return proto.CompactTextString(m) }
func (*BuildSignature) ProtoMessage()    {}
func (*BuildSignature) Descriptor() ([]byte, []int) {
	return fileDescriptor_a19bec1b0e925ab2, []int{1}
}

func (m *BuildSignature) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_BuildSignature.Unmarshal(m, b)
}
func (m *BuildSignature) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_BuildSignature.Marshal(b, m, deterministic)
}
func (m *BuildSignature) XXX_Merge(src proto.Message) {
	xxx_messageInfo_BuildSignature.Merge(m, src)
}
func (m *BuildSignature) XXX_Size() int {
	return xxx_messageInfo_BuildSignature.Size(m)
}
func (m *BuildSignature) XXX_DiscardUnknown() {
	xxx_messageInfo_BuildSignature.DiscardUnknown(m)
}

var xxx_messageInfo_BuildSignature proto.InternalMessageInfo

func (m *BuildSignature) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *BuildSignature) GetSignature() []byte {
	if m != nil {
		return m.Signature
	}
	return nil
}

func (m *BuildSignature) GetKeyId() string {
	if m != nil {
		return m.KeyId
	}
	return ""
}

func (m *BuildSignature) GetKeyType() BuildSignature_KeyType {
	if m != nil {
		return m.KeyType
	}
	return BuildSignature_KEY_TYPE_UNSPECIFIED
}

// Details of a build occurrence.
type Details struct {
	// Required. The actual provenance for the build.
	Provenance *provenance_go_proto.BuildProvenance `protobuf:"bytes,1,opt,name=provenance,proto3" json:"provenance,omitempty"`
	// Serialized JSON representation of the provenance, used in generating the
	// build signature in the corresponding build note. After verifying the
	// signature, `provenance_bytes` can be unmarshalled and compared to the
	// provenance to confirm that it is unchanged. A base64-encoded string
	// representation of the provenance bytes is used for the signature in order
	// to interoperate with openssl which expects this format for signature
	// verification.
	//
	// The serialized form is captured both to avoid ambiguity in how the
	// provenance is marshalled to json as well to prevent incompatibilities with
	// future changes.
	ProvenanceBytes      string   `protobuf:"bytes,2,opt,name=provenance_bytes,json=provenanceBytes,proto3" json:"provenance_bytes,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Details) Reset()         { *m = Details{} }
func (m *Details) String() string { return proto.CompactTextString(m) }
func (*Details) ProtoMessage()    {}
func (*Details) Descriptor() ([]byte, []int) {
	return fileDescriptor_a19bec1b0e925ab2, []int{2}
}

func (m *Details) XXX_Unmarshal(b []byte) error {
	return xxx_messageInfo_Details.Unmarshal(m, b)
}
func (m *Details) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	return xxx_messageInfo_Details.Marshal(b, m, deterministic)
}
func (m *Details) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Details.Merge(m, src)
}
func (m *Details) XXX_Size() int {
	return xxx_messageInfo_Details.Size(m)
}
func (m *Details) XXX_DiscardUnknown() {
	xxx_messageInfo_Details.DiscardUnknown(m)
}

var xxx_messageInfo_Details proto.InternalMessageInfo

func (m *Details) GetProvenance() *provenance_go_proto.BuildProvenance {
	if m != nil {
		return m.Provenance
	}
	return nil
}

func (m *Details) GetProvenanceBytes() string {
	if m != nil {
		return m.ProvenanceBytes
	}
	return ""
}

func init() {
	proto.RegisterEnum("grafeas.v1.build.BuildSignature_KeyType", BuildSignature_KeyType_name, BuildSignature_KeyType_value)
	proto.RegisterType((*Build)(nil), "grafeas.v1.build.Build")
	proto.RegisterType((*BuildSignature)(nil), "grafeas.v1.build.BuildSignature")
	proto.RegisterType((*Details)(nil), "grafeas.v1.build.Details")
}

func init() { proto.RegisterFile("proto/v1/build.proto", fileDescriptor_a19bec1b0e925ab2) }

var fileDescriptor_a19bec1b0e925ab2 = []byte{
	// 393 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x84, 0x92, 0xdd, 0x6e, 0x94, 0x40,
	0x14, 0xc7, 0x65, 0x6b, 0xbb, 0xe5, 0xb4, 0xd9, 0xe2, 0xd8, 0x26, 0x68, 0x34, 0x21, 0x5c, 0x28,
	0xde, 0xb0, 0x29, 0xde, 0x9b, 0xec, 0x07, 0xad, 0x84, 0x54, 0xc7, 0xd9, 0x6a, 0x5c, 0x6f, 0x26,
	0xb0, 0x3b, 0xe2, 0x84, 0x15, 0x08, 0x5f, 0xc9, 0x24, 0x3e, 0x8d, 0xaf, 0xe8, 0x0b, 0x98, 0x1d,
	0x70, 0x61, 0xd7, 0x8b, 0x5e, 0xc1, 0xff, 0x77, 0xfe, 0xe7, 0x8b, 0x03, 0x5c, 0x66, 0x79, 0x5a,
	0xa6, 0xe3, 0xfa, 0x7a, 0x1c, 0x56, 0x7c, 0xb3, 0xb6, 0xa5, 0x44, 0x5a, 0x94, 0x07, 0xdf, 0x59,
	0x50, 0xd8, 0xf5, 0xb5, 0x2d, 0xf9, 0xf3, 0x67, 0x3b, 0x5f, 0x96, 0xa7, 0x35, 0x4b, 0x82, 0x64,
	0xc5, 0x1a, 0xb3, 0x99, 0xc1, 0xf1, 0x74, 0xeb, 0x41, 0xaf, 0xe1, 0x42, 0x9a, 0x59, 0x4e, 0x6b,
	0x96, 0x17, 0x3c, 0x4d, 0x74, 0xc5, 0x50, 0x2c, 0x95, 0x8c, 0x5a, 0xfc, 0xa5, 0xa1, 0xe8, 0x1d,
	0xa8, 0x05, 0x8f, 0x92, 0xa0, 0xac, 0x72, 0xa6, 0x0f, 0x0c, 0xc5, 0x3a, 0x73, 0x0c, 0xfb, 0xb0,
	0xa5, 0x2d, 0x8b, 0x2e, 0xfe, 0xf9, 0x48, 0x97, 0x62, 0xfe, 0x51, 0x60, 0xb4, 0x1f, 0x45, 0x2f,
	0x01, 0xb2, 0x2a, 0xdc, 0xf0, 0x15, 0x8d, 0x99, 0x68, 0xdb, 0xaa, 0x0d, 0xf1, 0x99, 0x40, 0x2f,
	0x0e, 0x3b, 0x9e, 0xf7, 0xea, 0xa1, 0x2b, 0x38, 0x89, 0x99, 0xa0, 0x7c, 0xad, 0x1f, 0xc9, 0xc4,
	0xe3, 0x98, 0x09, 0x6f, 0x8d, 0x66, 0x70, 0xba, 0xc5, 0xa5, 0xc8, 0x98, 0xfe, 0xd8, 0x50, 0xac,
	0x91, 0x63, 0x3d, 0x34, 0xa5, 0xed, 0x33, 0x71, 0x2f, 0x32, 0x46, 0x86, 0x71, 0xf3, 0x62, 0xbe,
	0x87, 0x61, 0xcb, 0x90, 0x0e, 0x97, 0xbe, 0xbb, 0xa4, 0xf7, 0x4b, 0xec, 0xd2, 0xcf, 0x1f, 0x16,
	0xd8, 0x9d, 0x79, 0x37, 0x9e, 0x3b, 0xd7, 0x1e, 0xa1, 0x2b, 0x78, 0x82, 0x6f, 0x31, 0x9d, 0x2c,
	0x66, 0x9e, 0x47, 0x27, 0xe4, 0xee, 0x23, 0x71, 0xe7, 0x9a, 0x82, 0xce, 0xe1, 0x14, 0xfb, 0xde,
	0x57, 0x8a, 0xdd, 0x3b, 0x6d, 0x60, 0xfe, 0x82, 0xe1, 0x9c, 0x95, 0x01, 0xdf, 0x14, 0xe8, 0x06,
	0xa0, 0x3b, 0x83, 0xdc, 0xf6, 0xcc, 0x79, 0xd5, 0x9f, 0xad, 0x77, 0x24, 0x39, 0x20, 0xde, 0x69,
	0xd2, 0xcb, 0x44, 0x6f, 0x40, 0xeb, 0x14, 0x0d, 0x45, 0xc9, 0x0a, 0xf9, 0x75, 0x54, 0x72, 0xd1,
	0xf1, 0xe9, 0x16, 0x4f, 0x3f, 0xc1, 0x53, 0x9e, 0xfe, 0xb7, 0x3e, 0x56, 0xbe, 0x39, 0x11, 0x2f,
	0x7f, 0x54, 0xa1, 0xbd, 0x4a, 0x7f, 0x8e, 0xdb, 0xf0, 0xee, 0xb9, 0xff, 0x73, 0xd1, 0x28, 0xa5,
	0x92, 0xfc, 0x1e, 0x1c, 0xdd, 0x92, 0x49, 0x78, 0x22, 0xc5, 0xdb, 0xbf, 0x01, 0x00, 0x00, 0xff,
	0xff, 0x9f, 0x2c, 0x86, 0xff, 0x84, 0x02, 0x00, 0x00,
}
